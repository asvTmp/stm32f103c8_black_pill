# Настройка RCC

Вся тиория [тут](https://dimoon.ru/obuchalka/stm32f1/uroki-stm32f103-chast-4-nastroyka-rcc.html), выписал только практические действия.

Создадим функцию, в которую будем добавлять код инициализации:
```c
int ClockInit(void)
{
}
```  

Первым делом запускаем генератор HSE:

```c
RCC->CR |= (1<<RCC_CR_HSEON_Pos); //Запускаем генератор HSE
```  

После этого нам надо дождаться установки флага HSERDY, который указывает на успешный запуск генератора. Можно это сделать по-простому с помощью цикла while() {}, но тогда мы рискуем зависнуть в нем навсегда, если что-то случится с кварцевым резонатором. Хотелось бы иметь возможность каким-то образом сигнализировать о невозможности запуска. Вот моя реализация:   

```c
  __IO int StartUpCounter;
  //Ждем успешного запуска или окончания тайм-аута
  for(StartUpCounter=0; ; StartUpCounter++)
  {
    //Если успешно запустилось, то 
    //выходим из цикла
    if(RCC->CR & (1<<RCC_CR_HSERDY_Pos))
      break;
    
    //Если не запустилось, то
    //отключаем все, что включили
    //и возвращаем ошибку
    if(StartUpCounter > 0x1000)
    {
      RCC->CR &= ~(1<<RCC_CR_HSEON_Pos); //Останавливаем HSE
      return 1;
    }
  }
```  

Тут реализован тайм-аут на запуск HSE. Если генератор успел запуститься до возникновения условия if(StartUpCounter > 0x1000), то мы выходим из цикла for() с помощью инструкции break.

Так, HSE запустили. Переходим к настройке PLL:
```c
  //Настраиваем PLL
  RCC->CFGR |= (0x07<<RCC_CFGR_PLLMULL_Pos) //PLL множитель равен 9
            | (0x01<<RCC_CFGR_PLLSRC_Pos); //Тактирование PLL от HSE
```
Тут просто настраиваем коэффициент умножения и выбираем источник тактирования PLL. Далее, запускаем PLL:
```c
RCC->CR |= (1<<RCC_CR_PLLON_Pos); //Запускаем PLL
```

После этого ждем успешного запуска. Тут ожидание реализовано точно так же, как и для HSE:

```c
  //Ждем успешного запуска или окончания тайм-аута
  for(StartUpCounter=0; ; StartUpCounter++)
  {
    //Если успешно запустилось, то 
    //выходим из цикла
    if(RCC->CR & (1<<RCC_CR_PLLRDY_Pos))
      break;
    
    //Если по каким-то причинам не запустился PLL, то
    //отключаем все, что включили
    //и возвращаем ошибку
    if(StartUpCounter > 0x1000)
    {
      RCC->CR &= ~(1<<RCC_CR_HSEON_Pos); //Останавливаем HSE
      RCC->CR &= ~(1<<RCC_CR_PLLON_Pos); //Останавливаем PLL
      return 2;
    }
  }
```
После этого настраиваем FLASH и делители:
```c
  //Устанавливаем 2 цикла ожидания для Flash
  //так как частота ядра у нас будет 48 MHz < SYSCLK <= 72 MHz
  FLASH->ACR |= (0x02<<FLASH_ACR_LATENCY_Pos); 
  
  //Делители
  RCC->CFGR |= (0x00<<RCC_CFGR_PPRE2_Pos) //Делитель шины APB2 отключен (оставляем 0 по умолчанию)
            | (0x04<<RCC_CFGR_PPRE1_Pos) //Делитель нишы APB1 равен 2
            | (0x00<<RCC_CFGR_HPRE_Pos); //Делитель AHB отключен (оставляем 0 по умолчанию)
```
Ну и торжественный момент переключение на работу от PLL:
```c
RCC->CFGR |= (0x02<<RCC_CFGR_SW_Pos); //Переключаемся на работу от PLL
```
Ждем завершения переключения:
```c
  //Ждем, пока переключимся
  while((RCC->CFGR & RCC_CFGR_SWS_Msk) != (0x02<<RCC_CFGR_SWS_Pos))
  {
  }
```
Поздравляю! Мы запустились от PLL! После этого можно отключить RC-генератор HSI, так как он нам больше не нужен:
```c
  //После того, как переключились на
  //внешний источник такирования
  //отключаем внутренний RC-генератор
  //для экономии энергии
  RCC->CR &= ~(1<<RCC_CR_HSION_Pos);
```

Успешно завершаем настройку
```c
  //Настройка и переклбючение сисемы
  //на внешний кварцевый генератор
  //и PLL запершилось успехом.
  //Выходим
  return 0;
```

Полный код смотри в [статьетут](https://dimoon.ru/obuchalka/stm32f1/uroki-stm32f103-chast-4-nastroyka-rcc.html#nastroika), спасибо автору.  

